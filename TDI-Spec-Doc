Title : TDI Specification
Title Note: version 1.1.0
Title Footer: &date;
Author: Sayan Bandyopadhyay and James Choi
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr

Tex Header:
  \setlength{\headheight}{30pt}
  \setlength{\emergencystretch}{2em}

Bib: references.bib
Bib Search Url:

Script: https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js
Script: bibref_no_title.js

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
Colorizer: proto
Colorizer: prototext
Colorizer: cpp

.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````p4&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````p4&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if html {
pseudo {
  replace: "~ Begin PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
pseudo {
  replace: "~ Begin PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
cpp {
  replace: "~ Begin CPPblock&nl;\
                 ````cpp&nl;&source;&nl;````&nl;\
                 ~ End CPPblock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
cpp {
  replace: "~ Begin CPPblock&nl;\
                 ````cpp&nl;&source;&nl;````&nl;\
                 ~ End CPPblock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
proto {
  replace: "~ Begin Protoblock&nl;\
                 ````proto&nl;&source;&nl;````&nl;\
                 ~ End Protoblock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
proto {
  replace: "~ Begin Protoblock&nl;\
                 ````proto&nl;&source;&nl;````&nl;\
                 ~ End Protoblock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
prototext {
  replace: "~ Begin Prototextblock&nl;\
                 ````prototext&nl;&source;&nl;````&nl;\
                 ~ End Prototextblock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
prototext {
  replace: "~ Begin Prototextblock&nl;\
                 ````prototext&nl;&source;&nl;````&nl;\
                 ~ End Prototextblock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
  
}
}

[TITLE]

~ Begin Abstract
Table Driven Interface (TDI) is a runtime control plane specification and a set of APIs that enable the management 
of P4 programmable and non-P4 fixed functions of a backend device in a uniform and dynamic way. 
~ End Abstract

[TOC]
[TOC=figures]
[TOC=tables]

# Terms and Definitions

~ TableFigure { #terms-and-definitions; \
    caption: "Terms and Definitions"; \
    page-align: forcehere; }
|--------------------------------|------------------------------------------------------------|
|     Terms                      |        Definitions                                         |
+---{width:4cm}------------------+------------------------------------------------------------+
| BFRT                           | Native C++ and C control plane API, which is the           |
|                                | predecessor to TDI.                                        |
+--------------------------------+------------------------------------------------------------+
| Context.json                   | File generated by P4C backend of target used by TDI        |
|                                | frontend and TDI target backend to program the target      |
|                                | device pipeline.                                           |
+--------------------------------+------------------------------------------------------------+
| Fixed Function                 | Non-P4 functionalities (for example, port management       |
|                                | and traffic management).                                   |
+--------------------------------+------------------------------------------------------------+
| MAT                            | Match Action Table                                         |
+--------------------------------+------------------------------------------------------------+
| P4C                            | P4 Compiler                                                |
+--------------------------------+------------------------------------------------------------+
| P4Runtime                      | The runtime control plane specification for PSA.           |
+--------------------------------+------------------------------------------------------------+
| PSA                            | Portable Switch Architecture, a target architecture that   |
|                                | describes common capabilities of network switch devices    |
|                                | that process and forward packets across multiple interface |
|                                | ports.                                                     |
+--------------------------------+------------------------------------------------------------+
| Programmable Function          | P4 programmable functions.                                 |
+--------------------------------+------------------------------------------------------------+
| PNA                            | Portable NIC Architecture                                  |
+--------------------------------+------------------------------------------------------------+
| tdi.json / TDI.json            | File generated by P4C frontend according to TDI schema     |
|                                | for use in the runtime control plane.                      |
+--------------------------------+------------------------------------------------------------+
| TDI Frontend                   | The frontend layer that implements the TDI APIs and        |
|                                | converts them to the form that the TDI target backend      |
|                                | expects.                                                   |
+--------------------------------+------------------------------------------------------------+
| TDI Implementation             | TDI backend C++ classes that implement functionalities and |
|                                |  the corresponding functionality-specific TDI JSON files.  |
+--------------------------------+------------------------------------------------------------+
| TDI Interface                  | TDI C/C++ API and the TDI parser of the TDI schema.        |
|                                |                                                            |
+--------------------------------+------------------------------------------------------------+
| TDI Repo                       | Device independent TDI frontend C/C++ code that is         |
|                                | shared by multiple devices.                                |
+--------------------------------+------------------------------------------------------------+
| TDI Target Backend             | The target specific backend that configures the target     |
|                                | pipeline using the metadata from the context.json          |
+--------------------------------+------------------------------------------------------------+
| TNA                            | Tofino Native Architecture                                 |
+--------------------------------+------------------------------------------------------------+
~

# 	Introduction to TDI

Table Driven Interface (TDI) is a runtime control plane specification and a set of APIs that enable the management 
of P4 programmable and non-P4 fixed functions of a backend device in a uniform and dynamic way. TDI is a Device Independent (DI) 
interface and has “common code” in one place for devices.   Other manufactures   can use TDI to implement their PSA or any architecture 
(for example, TNA or PNA).


~ Figure { #fig-image1; \
caption: "TDI High Level Design Diagram" }
![image1]
~
[image1]: media/image1.[svg,png] \
{ height: 7cm; page-align: here }

The fixed and the P4 programmable functions use common set of JSON schema that describes all functions as table key and data attributes. 
A uniform API can be used for programming both fixed and P4 programmable functions. Also, the usage of a separate JSON file for defining 
the semantics of the TDI API enables the syntax of the API to be uniform for all target devices and all features. It also enhances the dynamic 
upgradability of the network feature attributes.  

# TDI JSON Workflow

TDI.JSON file acts as a contract between the control plane and frontend. TDI backend is implemented using the context.json file.

~ Figure { #fig-image2; \
caption: "TDI JSON Workflow" }
![image2]
~
[image2]: media/image2.[svg,png] \
{ height: 7cm; page-align: here }

Characteristics of TDI implementation:

*	TDI API header layer provides the common interface for all device capabilities.
*	TDI C++ implementation layer overrides the TDI interface API with the functionality specific C++ methods.
*	Backend functionality managers implement device-specific functionalities. 
*	Backend functionality managers utilize the low-level driver for configuring a device. 

##	P4 Programmable Functions

A P4 pipeline program is compiled to generate a set of files (tdi.json and context.json  ) which are used by P4Runtime, TDI library, 
and the target pipeline.  P4Runtime is a gRPC based specification for the management of the P4 device by a controller. The P4Runtime 
client and server use the p4runtime.proto    as the common message format of the P4 program objects. P4Runtime server additionally 
uses the metadata related to the P4 objects from the TDI API to program the TDI API interface.   

Unlike TDI's predecessor (BFRT), p4c generated JSON file contains externs  in table format. The externs of P4Runtime objects from p4info  
needs to be mapped to TDI objects from tdi.json.

**Note**: P4 DPDK TDI feature C++ classes along with the target specific managers, dynamically adjust the mapping to target pipeline by using the context.json file.

##	Non-P4 Fixed Functions

The management of non-P4 fixed functions, like port management or traffic management, is done the similar way using the JSON files. 
The semantics of a fixed function TDI API are defined by a JSON file that defines the table attributes of the fixed function. 
These fixed function JSONs are hand-written.

**Note 1**: You can also generate fixed function JSON from other data models. The fixed function controllers like gRPC-based OpenConfig (gNMI, gNOI) 
use the common messages defined by the YANG models of the fixed function objects. OpenConfig server additionally uses the metadata related to the 
fixed function objects from the TDI API to program the TDI API interface for the message requests. 

**Note 2**: The dynamic update of the fixed function JSON file is possible, but it is not supported in P4 DPDK for now.

The TDI library maps the APIs to the target device configurations. The mapping of fixed function TDI API to backend device configuration is hardcoded. 
You can do such mapping through usage of a file like context.json. 

The P4 programmable and non-P4 fixed function TDI tables follow the same schema, and the organization of the fields are common. 
The following tables show compiler generated tdi.json for a P4 table and hand-written port.json for a port table.

~ Begin Proto
|-------------------------------------------------------------|------------------------------------------------------------|
|     P4 Table (TDI.JSON from P4C)                            |        Fixed Table (PORT.JSON)                             |
+---{width:7cm}-----------------------------------------------+------------------------------------------------------------+
| "tables" : [                                                | "tables" : [                                                            
|    {                                                        |     {                                                         
|     "id" : 45300881, "name" : "routing_v4",                 |       "id" : 4278255617, "name" :                                                          
|     "key" : [                                               | "$PORT",
|       {                                                     |       "key" : [{"id" : 1,"name" : 
|         "id" : 1,"name" : "ipv4_dst",                       | "$DEV_PORT",}],
|         "match_type" : "LPM"                                |       "data" : [
|         "type" : { "type" : "bytes", "width" : "32",}       |         {
        }                                                     |           "singleton" : {
      ],                                                      |             "id" : 1, "name" : "$SPEED",
      "action_specs" : [                                      |             "type" : {
        {                                                     |               "choises" : [
          "id" : 19792090, "name" : "set_next_id",            |                   "BF_SPEED_1G"
           "data" : [                                         |                   "BF_SPEED_10G"
             {                                                |                   ...
              "id" : 1, "name" : "next_id",                   |                   "BF_SPEED_400G"
              "type" : {"type" : "bytes", "width" : "32",}    |                  ]
             }                                                |             }
          ]                                                   |           }
        },                                                    |         },
        {                                                     |         {
          "id" : 29734112, "name" : "drop",                   |           "singleton" : {
          "date" : []                                         |             "id" : 2, "name" : "$FEC",
        }, ...                                                |             ...
+-------------------------------------------------------------+------------------------------------------------------------+                                                                                            
~ End Proto

# Benefits of TDI  

TDI abstracts all device functionalities as tables with keys and data that are defined solely in JSON files, which help to provide uniform API 
and dynamic upgradability. Uniform interface allows broad adaptation of TDI to different devices. TDI implementation helps avoiding recompilation 
of application code upon changing the P4 program when adding new functionality or features. 

## Uniform Interface

TDI provides a uniform interface for both P4 objects (for example, tables, actions, and action selectors) and non-P4 fixed objects 
(for example, port and QoS nodes). The uniform design concept provides the following capabilities :

*	Programming of all features using a common set of C and C++ APIs as the table keys and defining data through JSON files.
*	The implementation of each feature is hidden behind API thru C++ polymorphism. 
*	The capability of operations supported for each feature table can be learned in uniform manner.
*	TDI C/C++ API is program and protocol independent.    
*	TDI C/C++ API is P4 architecture independent. There are no P4 table or extern names reflected in the TDI API.
##	Dynamic Update 

TDI is designed to support dynamic upgrade of feature table semantics. The dynamic update capability provides following capabilities:

*	P4 tables support dynamic update of table keys and data (for example, `SetForwardingPipelineConfig` support) through separating table semantics separated in files. 
*	Through optional use of CONTEXT files, some mapping of TDI user requests target specific configuration can also be dynamically updated. 

#	Infrastructure APIs

TDI uses a set of C++ and C table APIs and infrastructure APIs. These APIs are program, protocol, and architecture independent which enable you to 
use them in different platforms.  Infrastructure APIs work with the table APIs to enhance TDI usability. These APIs are not table-driven or JSON-driven.

##	TdiInfo

TdiInfo C++ class provides access to the top-level metadata extracted from all JSON files. During the TDI initialization, 
all the JSON files are read by the TDI library, and the metadata for all tables is maintained in the TDI library. 
This includes both P4 and fixed function files. All the table objects of the device can be accessed through the TdiInfo class. 

The TdiInfo class provides access to information such as number of tables, name to/from ID mapping of objects in JSON files, 
and table dependency information. For example, a control plane can access the supported port attributes extracted from the 
consumed port.json file using the `tableFromNameGet` method API.

~ Begin Proto
tdi_status_t TdiInfo::tableFromNameGet(const std::string &name,
                                        const tdi::Table **table_ret) const;
~ End Proto


